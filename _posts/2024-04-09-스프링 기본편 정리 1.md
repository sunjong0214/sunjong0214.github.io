---
title : 스프링 핵심 원리 - 관심사 분리와 IoC와 DI
categories : [Spring]
tags : [spring, singleton, component, bean, config]
---



## 관심사 분리

- 애플리케이션을 설계할 때 관심사 분리를 해야한다.
- 하지만 관심사 분리라는 말을 처음 들으면 무슨 의미인지 파악이 어렵다.
- 관심사 분리에 대해 알아보자.



 ```java
 public class OrderServiceImpl implements OrderService {
 	private final MemberRepository memberRepository = new MemoryMemberRepository();
 	private final DiscountPolicy discountPolicy = new FixDiscountPolicy(); 
     
     @Override
 	public Order createOrder(Long memberId, String itemName, int itemPrice) {
 		
         Member member = memberRepository.findById(memberId);
 	
         int discountPrice = discountPolicy.discount(member, itemPrice); 
 		
         return new Order(memberId, itemName, itemPrice, discountPrice);
     } 
 }
 ```

위와 같은 코드는 주문서비스를 구현한 구현 클래스이다. 위 클래스는 OrderService를 구현한 클래스로 객체지향의 추상화를 잘 지켜서 만든 코드라고 볼 수 있다.

하지만 이 관심사 분리라는 입장에서 보면 위 코드는 큰 문제가 있다.

바로 `객체의 생성, 할당과 객체의 실행 코드가 한 클래스 안에 존재한다는 것`이다.

만약 memberRepository의 구현체를 Memory가 아닌 JDBC를 사용해야 한다면 위의 코드를 수정해야한다. 즉, SOLID 패턴의 `OCP(Open-Closed Principle)를 위반`한 것이다.

또 사실 OrderService를 상속 받으며 추상화를 지키려 했지만 객체를 할당하는 부분을 잘 보면 추상 클래스를 의존하는 것 뿐만 아니라 구체 클래스도 함께 의존하고 있다. 즉, `SOILD 패턴의 DIP(Denpendency Inversion Principle)도 위반`하고 있다. 

```java
					(추상 클래스)							(구체 클래스)
private final MemberRepository memberRepository = new MemoryMemberRepository();
private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
```

그림으로 살펴보면 다음과 같다.

![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/3d9f1cca-864b-478e-b66a-0b067e52da09)

이와 같은 문제를 어떻게 해결하기 위해선 다음과 같이 코드를 변경해야한다.

```java
public class OrderServiceImpl implements OrderService {
	//private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); 
	private DiscountPolicy discountPolicy;
}
```

하지만 위 코드는 구현체가 없기 때문에 NPE(Null pointer exception)가 발생한다.

이런 문제를 해결하기 위해선 밖에서 구현체를 주입 시켜줘야한다.

이때 필요한 것이 DI(Dependency Injection)이다.



## AppConfig

OrderServiceImpl에 생성자 도입

```java
public class OrderServiceImpl implements OrderService {
	//private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); 
	private DiscountPolicy discountPolicy;
    
    public OrderServiceImpl(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

AppConfig 작성

```java
public class AppConfig {
    public OrderService orderService() {
		return new OrderServiceImpl(
			new FixDiscountPolicy());
    }
}
```

다음과 같이 AppConfig를 도입해 OrderServiceImpl 클래스에서 사용, 구성을 분리하였다.

그림으로 살펴보면 다음과 같다.

![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/65c2b749-4868-4253-961c-d02338612174)

이런 흐름을 `제어의 역전 IoC`라고 한다.



#### IoC (Inversion of Control)

- 기존에는 구현 객체에서 필요한 객체들을 직접 생성하고 할당했다.
- 하지만 AppConfig가 등장한 후 구현 객체는 자신의 로직만 실행하게 바뀌었다. 즉, 프로그램의 제어 흐름은 AppConfig가 담당하는 것이다.
- 예를 들어, OrderServiceImpl은 필드에 인터페이스만 가지고 있다. 그 인터페이스에 `어떤 구현 객체가 할당되는지는 OrderServiceImpl은 알지 못한다.` 자신의 `로직만을 실행`할 뿐이다.
- 이렇듯 `프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것`을 IoC라고 한다.



#### IoC 컨테이너, DI 컨테이너

- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을
- IoC 컨테이너 또는 DI 컨테이너라 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다. 
- 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.



## 스프링 적용

- 지금까지의 AppConfig 순수 자바 코드로 설정했다. 이제 Spring을 통해 설정해보자.



```java
@Configuration
public class AppConfig {
    @Bean
    public OrderService orderService() {
		return new OrderServiceImpl(
			new FixDiscountPolicy());
    }
}
```

- AppConfig에 @Configuration을 붙여주고, 각 메소드에 @Bean을 붙여준다. 이렇게 하면 스프링 컨테이너에 스프링 빈으로 등록된다.

#### Main

```java
public class MemberApp {
public static void main(String[] args) { 
//		  순수 자바
//        AppConfig appConfig = new AppConfig();
//        MemberService memberService = appConfig.memberService();
    
//	스프링 컨테이너 사용 시
	ApplicationContext applicationContext = new
	AnnotationConfigApplicationContext(AppConfig.class);
    
	MemberService memberService =
	applicationContext.getBean("memberService", MemberService.class);
    
	Member member = new Member(1L, "memberA", Grade.VIP);
    	    memberService.join(member);
    
	Member findMember = memberService.findMember(1L);
    
	System.out.println("new member = " + member.getName()); 
	System.out.println("find Member = " + findMember.getName());
    } 
}
```



#### 스프링 컨테이너

- `ApplicationContext`를 스프링 컨테이너라고 부른다.

- 스프링 컨테이너는 `@Configuration 이 붙은 AppConfig 를 설정(구성) 정보로 사용`한다. 여기서 `@Bean 이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록`한다. 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- 스프링 컨테이너에서는 순수 자바 코드와 다르게 스프링 빈을 찾아서 사용해야된다. 스프링 빈은 `applicationContext.getBean()`메소드를 통해 찾아 사용할 수 있다.





## 스프링 빈

- 스프링 빈에는 각 객체에 `이름과 타입으로 저장`된다.
- 빈 이름은 항상 다른 이름을 부여해야 한다. 같은 이을 부여할 시, 오류가 발생한다.
- 실제 스프링에서 스프링은 빈 생성과 의존관계 주입하는 단계가 나누어져있다.



#### 스프링 빈 조회 시 상속 관계

![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/8ebd41fc-4017-4c61-91d2-cc9f87a66313)



#### BeanFactory와 ApplicationContext

![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/7876d0a8-b03d-4c07-bd6a-a2e6325c1b26)

`BeanFactory`

- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할

`ApplicationContext`

- BeanFactory 기능을 상속받아 제공
- BeanFactory의 스프링 빈 관리, 조회 기능 뿐만 아니라 다른 부가 기능을 제공

`ApplicationContext의 부가기능`

- 메시지소스를 활용한 국제화 기능
  
  예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력 
  
- 환경변수

  로컬, 개발, 운영등을 구분해서 처리

- 애플리케이션 이벤트
  
  이벤트를 발행하고 구독하는 모델을 편리하게 지원 
  
- 편리한 리소스 조회
  
  파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

BeanFactory나 AplicationContext를 스프링 컨테이너라 한다.



#### 스프링 빈 설정 메타 정보 - BeanDefinition

- 스프링은 BeanDefinition이라는 추상화로 다양한 설정 형식을 지원한다. (xml, annotation 등)

![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/e79e30ca-f5d5-423a-b843-1dadecf7ef07)

- 이렇게 생성한 `BeanDefinition`을 `빈 설정 메타정보`라고 하고, 이러한 `메타정보를 기반으로 스프링 빈을 생성`한다.