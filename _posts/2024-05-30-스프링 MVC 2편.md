---
title : 스프링 MVC 2
categories : [Spring]
tags : [spring, mvc]
---

## 메시지, 국제화

- 스프링에서는 다양한 메시지를 한 곳에서 관리하는 기능인 메시지 기능과 메시지의 국제화를 할 수 있는 기능을 제공한다.

#### 메시지

  - 우리가 어떤 개발한 애플리케이션에서 상품 이름과 관련된 문구를 상품명이라고 정했다고 가정하자.

  - 근데 요구사항이 변경되어 상품명 -> 상품이름으로 변경해야 되고, 이에 따라 변경해야되는 파일들이 수십개 이상이라면 하드코딩된 상품명을 모두 고쳐야하는 상황이 발생한다.

  - 이런 상황을 `messages.properties`에 key-value로 값을 설정한 뒤 그 값을 사용함으로써 해결 가능하다.

    ```java
    item=상품
    item.id=상품 ID
    item.itemName=상품명
    ```

#### 국제화

  - 메시지 기능은 국제화 기능 또한 제공한다.
  - 만약, 영어와 한글을 지원하는 애플리케이션을 만들었다면, messages_en.properties(영어)와 messages.properties(한글) 두 파일을 만들어 관리하면 된다.
  - 국제화 기능은 HTTP accept-language 헤더 값을 이용하는 등의 방법으로 사용자의 선호 언어에 맞춰 기능한다. 

#### 스프링 메시지 소스

- 스프링에서 메시지 관리 기능을 사용하기 위해선 `MessageSource`를 스프링 빈에 등록시켜야된다.

- 스프링 부트에서는 기본적으로 등록해주기 때문에 개발자가 따로 MessageSource를 구현할 필요는 없다. 별도의 설정을 하지 않으면 messages라는 이름으로 기본 등록된다.

- MessageSource 사용 방법

  ```java
  //messages.properties
  hello=안녕
  hello.name=안녕 {0}
  ```

  - `정상 작동`

    ```java
    @SpringBootTest
    public class MessageSourceTest { 
        @Autowired
    	MessageSource ms; 
        @Test
    	void helloMessage() {
            Stirng result = ms.getMessage("hello", null, null);
            assertThat(result).isEqualto("안녕");
        } 
    }
    ```

  - `메시지가 없는 경우, 기본 메시지 설정`

    ```java
    @Test
    void notFoundMessageCode() {
    	assertThatThrownBy(() -> ms.getMessage("no_code", null, null)) 
                .isInstanceOf(NoSuchMessageException.class);
    }
    @Test
    void notFoundMessageCodeDefaultMessage() {
    	String result = ms.getMessage("no_code", null, "기본 메시지", null); 
    	assertThat(result).isEqualTo("기본 메시지");
    }
    ```

    메시지가 없는 경우 NoSuchMessageException이 발생하고, 메시지가 없어도 defaultMessage를 사용하면 기본 메시지가 반환된다.
  
  - `매개변수 사용`
  
    ```java
    @Test
    void argumentMessage() {
    	String result = ms.getMessage("hello.name", new Object[]{"Spring"}, null); 
    	assertThat(result).isEqualTo("안녕 Spring");
    }
    ```
  
    매개변수를 사용해 치환이 가능하다. hello.name=안녕 {0} -> 안녕 Spring
  
  - 타임리프에서의 사용법
    ```java
    <div th:text="#{hello}"/>
    //파라미터 hello.name=안녕 {0}
    //() 안에 원하는 값을 넣으면 치환이 가능
    <p th:text="#{hello.name(...)}"></p>
    ```
  
    #{...}으로 메시지를 편리하게 조회할 수 있다.
  
- 스프링 국제화

  - 스프링에서 제공하는 MessageSource는 Locale 정보를 가지고 언어를 한다.
  - 스프링은 Locale 선택 방식을 변경할 수 있도록 `LocaleResolver 인터페이스`를 제공한다.
  - 스프링 부트는 기본으로 HTTP의 Accept-Language를 활용하는 `AcceptHeaderLocaleResolver`를 사용하는데 만약 Locale 선택 방식을 바꾸고 싶다면 직접 LocaleResolver를 구현하면 된다.

## Bean Validation

- 스프링에서는 요청 시 들어온 데이터를 검증할 수 있는 Validation을 제공한다.
- @Validated와 BindingResult를 사용해 검증을 할 수 있다.
- BindingResult를 통해 validation과 표시할 메시지는 errors.properties에 따로 정의해 스프링 메시지와 함께 사용 가능하다.
- 주의할 점은 API 설계시 @RequestBody를 사용할 때 주의해야한다.
  - Form으로 넘어온 데이터의 경우 Type이 맞지 않을 때 TypeDismatch 오류가 BindingResult의 FieldError로 생성된다.
  - 하지만 JSON으로 넘어온 데이터의 Type이 맞지 않을 시 HttpMessageConverter에서 요청 JSON으로 객체를 생성하지 못하기 때문에 BindingResult로 가기 전에 예외를 던진다.
  - 이럴 때 HttpMessageConverter 단계에서 예외 발생 시 우리가 원하는 모양으로 만들기 위해 @ExceptionHandler을 사용해야한다.



## 쿠키와 세션

- 로그인 유지를 위해 보통 세션을 사용한다.
- 세션이 어떻게 동작하는지 알아보자.
- 세션에 대해 얘기 하기 전 쿠키에 대해 먼저 알 필요가 있다.



#### 쿠키

- 로그인 시 쿠키를 사용할 시 Response에 쿠키 생성해 응답해주면 된다.

  ```java
  @PostMapping("/login")
  public String login(@ModelAttribute LoginForm from, HttpServlcetResponse response) {
      // member의 id를 찾는 로직 생략
      Cookie idCooki = new Cookie("memberId", String.valueOf(loginMember.getId())); // 쿠키는 <String, String>
      response.addCookie(idCookie);
      return "redirect:/";
  }
  ```

- 이와 같이 쿠키를 생성하면 각 url 요청시 헤더에 Cookie로 member의 id를 받아 어떤 유저가 로그인했는지 식별이 가능하다.

- 문제점 : 쿠키로도 충분히 로그인 유지가 가능하지만 심각한 보안 문제가 존재한다.

  - 쿠키 값은 임의로 변경 가능
  - 쿠키에 보관된 정보도 훔칠 수 있고, 해커가 쿠리를 한번 훔쳐가면 평생 사용 가능

- 해결책 

  - 쿠키에 중요한 값을 노출 X, 사용자 별로 예측 불가능한 임의의 토큰을 노출하고 서버에서 토큰과 사용자 Id를 매핑해서 인식. 그리고 서버에서 토큰을 관리
  - 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 해야함(UUID 사용)



#### 세션

- 위의 해결책을 모두 충족하는 것이 보통 우리가 사용하는 세션이다.

- 사실 세션은 Cookie를 기반으로 동작한다.

  ![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/bf50f8fa-f423-4147-ba89-24ecc58f82c0)

- 세션은 요청이 들어오면 사용자를 검증한 뒤 세션 저장소(Map 사용)에 UUID로 생성한 sessionId와  객체를 저장해준다.

- 그 다음 sessionId를 쿠키에 담아서 클라이언트에 보내준다.

  ![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/836d6813-e3b3-4724-ba88-23923acecb2b)

- 결국 클라이언트와 서버는 `쿠키로 연결` 되어야 하고, 중요한 포인트는 `회원과 관련된 정보는 클라이언트에 전달하지 않는다`는 것이다.

- 로그인 후 요청시에는 sessionId 쿠키를 항상 전달한다.

- 서버에서는 클라이언트가 전달한 sessionId 쿠키 정보로 세션 저장소에서 보관한 화원 정보를 사용하게 된다.

  ![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/cf85f900-e5ea-4616-9426-a2e93fd802e4)

- 이로써 보완과 관련된 문제가 해결되었다.

- 세션의 생존 시간은 최근에 요청한 시간을 기준 업데이트 된다. HttpSession도 이런 방식으로 동작한다.

## 서블릿 필터와 스프링 인터셉터

- Spring은 공통적으로 필요한(공통 관심사) 여러 처리들을 도와줄 수 있는 기능들을 지원한다.
- 그 중 서블릿이 지원해주는 서블릿 필터와 스프링이 제공하는 스프링 인터셉터에 대해 알아보자.
- 이 둘의 특징으로는 Request 객체와 Response 객체를 제공해 웹과 관련된 처리를 편리하게 할 수 있다. (AOP와 다른 점)

#### Servlet Filter

- 서블릿 필터는 서블릿 컨테이너에서 제공하는 공통 처리 기능이다.

- `필터 흐름`

  ```java
  HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러
  //필터에 걸릴 시
  HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이라 판단, 서블릿 호출 X)
  ```

  `필터 체인`

  ```java
  HTTP 요청 -> WAS -> 필터1 -> 필터2 -> 필터3 -> 서블릿 -> 컨트롤러
  ```

- `필터 인터페이스`

  ```java
  public interface Filter {
  	public default void init(FilterConfig filterConfig) throws ServletException {};
      
  	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;
      
  	public default void destroy() {}; 
  }
  ```

  - init() : 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출
  - doFilter() : 요청이 올 때 마다 해당 메서드가 호출. 핵심 로직
  - destroy() : 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출

- `필터 구현`

  ```java
  public MyFilter implements Filter {
      @Override
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
          // 로직 생략
          
          try {
              chain.doFilter(request, response);
          } catch (Exception e) {
  			throw e;
          } finally {
          }
      }
  }
  ```

  - 필터를 구현할 때 doFilter()를 제외한 메서드는 default 메서드로 구현하지 않아도 된다.
  - doFilter() 에서는 필터링 로직을 구현한 뒤 chain.doFilter로 다음 필터가 있을 시 호출 해줘야 한다.
  - 만약 필터가 하나일 때도 chain,doFilter()를 꼭 호출 해줘야 한다. 호출 하지 않는다면 다음으로 넘어가지 않는다. 즉, 서블릿이 띄워지지 않는다.

- `필터 설정`

  ```java
  @Configuration
  public class WebConfig { 
      @Bean
  public FilterRegistrationBean logFilter() {
  	FilterRegistrationBean<Filter> filterRegistrationBean = new
  	FilterRegistrationBean<>();        filterRegistrationBean.setFilter(new LogFilter());
          filterRegistrationBean.setOrder(1);
          filterRegistrationBean.addUrlPatterns("/*");
  	return filterRegistrationBean;
      } 
  }
  ```

  - 필터는 위와 같이 FilterRegistrationBean을 사용해 등록하면 된다.
  - setFilter : 등록할 필터를 지정, setOrder : 필터 체인 순서 지정, addUrlPatterns : 필터를 적용한 URL 패턴 지정 등 다양한 메서드를 지원한다.

- `서블릿 필터 VS 스프링 시큐리티`

  - 필터와 시큐리티는 사용자 `인증 및 인가 기능`을 구현하는데 쓰인다.

  - 스프링 시큐리티도 결국 서블릿 필터를 기반으로 동작한다.
  - 하지만 서블릿 필터의 경우 설정과 구현에 다소 번거롭고, 구체적인 인증 및 인가 로직은 직접 구현해야된다. 또 다른 스프링 모듈과의 통합이 복잡할 수 있다.
  - 이런 점을 편리하게 사용할 수 있게 스프링에서 인증 및 인가를 위한 스프링 시큐리티를 제공한다.
  - 스프링 시큐리티는 더욱 강력한 보안 기능(CSRF 방지 등)을 제공하고 보다 높은 추상화를 제공해 설정이 편리하다.



#### 스프링 인터셉터

- 스프링 인터셉터도 필터와 같이 공통 관심 사항 처리를 도와주는 기능이다.

- 둘 다 웹과 관련된 공통 관심 사항 처리를 도와주지만, 적용되는 순서와 범위, 사용 방법에 차이가 있다.

- `필터 VS 인터셉터`

  - `필터` : 공통된 보안 및 인증/인가, 모든 요청에 대한 로깅 또는 감사 등

  - `인터셉터` : 세부적인 보안 및 인증/인가 작업, API 호출에 대한 로깅 또는 감사, Controller로 넘겨주는 데이터의 가공 등

- `스프링 인터셉터 흐름`

  ```java
  HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러
  ```

- `스프링 인터셉터 제한`

  ```java
  HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링인터셉터 -> 컨트롤러 //로그인 사용자
  HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링인터셉터(적절하지 않은 요청이라 판단, 컨트롤러 호출 X) // 비 로그인 사용자
  ```

- `스프링 인터셉터 체인`

  ```java
  HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터1 -> 인터셉터2 -> 컨트롤러
  ```

- `스프링 인터셉터 인터페이스`

  ```java
  public interface HandlerInterceptor {
      
  	default boolean preHandle(HttpServletRequest request, HttpServletResponse 
  response, Object handler) throws Exception;
  	
      default void postHandle(HttpServletRequest request, HttpServletResponse 
  response, Object handler, @Nullable ModelAndView modelAndView) throws Exception;
      
  	default void afterCompletion(HttpServletRequest request, HttpServletResponse response, javaObject handler, @Nullable Exception ex) throws Exception;
      
  }
  ```

- `스프링 인터셉터 호출 흐름`

  ![image](https://github.com/sunjong0214/algorithm-study/assets/117134728/843c7249-123f-47c9-9090-2082c574bfe8)

- `예외 발생 시 흐름`

  - 컨트롤러에서 예외 발생 시 postHandle는 호출 되지 않음
  - 하지만 afterCompletion은 예외와 상관 없이 호출 됨
  - 예외와 무관하게 공통 처리를 하려면 afterCompletion을 사용하면 됨

- `구현`

  - preHandle를 구현 시 우리가 작성한 핸들러들의 정보를 받아올 수 있게 handler를 파라미터로 제공한다.

  - 하지만 다양한 핸들러들을 지원하기 위해 Object 클래스로 되어있어 HandlerMethod로 캐스팅 해주면 해당 컨트롤러의 다양한 정보들을 사용 가능하다.

    ```java
    if (handler instanceof HandlerMethod) {
    	HandlerMethod hm = (HandlerMethod) handler; //호출할 컨트롤러 메서드의 모든 정보가 포함되어 있다.
    }
    ```

  - `HandlerMethod` : @RequestMapping이 붙은 메소드의 정보를 추상화한 객체로 해당 메소드의 여러 메타 정보들을 가지고 있다 (파라미터 정보, 리턴 값 등)

- `인터셉터 등록`

  ```java
  @Configuration
  public class WebConfig implements WebMvcConfigurer { 
      @Override
  	public void addInterceptors(InterceptorRegistry registry) { 
          registry.addInterceptor(new LogInterceptor()) 
                  .order(1)
                  .addPathPatterns("/**")
                  .excludePathPatterns("/css/**", "/*.ico", "/error"); 
      }
  }
  ```

  - addInterceptors를 통해 등록하면 된다.
  - 서블릿 필터와 다르게 url 패턴을 더욱 상세히 적용할 수 있다. 



## 서블릿 예외 처리

- 서블릿 예외 처리에는 두 가지 종류가 있다.

- Exception : 예외

  - 웹 애플리케이션에서 예외가 발생 시 중간에 예외를 처리하는 로직이 없다면 WAS까지 예외가 던져지게 된다.

    ```java
    WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)
    ```

  - 이럴 시 WAS는 기본으로 제공하는 해당 오류에 맞는 오류 페이지를 제공해준다.

- response.sendError(HTTP 상태코드, 오류 메시지)

  - 오류가 발생 시 예외를 던지지 않고 response.sendError() 메서드를 사용해도 된다.

  - 이 메소드를 호출하면 당장 예외가 발생하는 것은 아니지만, 서블릿 컨테이너에게 오류가 발생했다는 점을 전달할 수 있다.

    ```java
    WAS(sendError 호출 기록 확인) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러 
    (response.sendError())
    ```

  - response 내부에 오류가 발생했다는 상태를 저장한 뒤 WAS에서 sendError가 호출 되었다면 오류 코드에 맞춰 기본 오류 페이지를 보여준다.



출처) 

[스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 | 김영한 - 인프런 (inflearn.com)](https://www.inflearn.com/course/스프링-mvc-2)