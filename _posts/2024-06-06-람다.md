---
title : 함수형 인터페이스, 람다 표현식
categories : [Java]
tags : [java]
---



## 함수형 인터페이스

- 정확히 `하나의 추상 메서드만 존재`하는 인터페이스이다.
- 이를 통해 우리가 동적 파라미터화 된 메소드에 람다나 익명 클래스로 직접 코드를 보낼 수 있다.
- 또한 `디폴트 메서드를 통해 하나의 추상 메서드 외에 다양한 메서드를 사용할 수 있다.
- 쉽사리 이해가 되지 않는다면 Comparator 인터페이스를 참고해보자. 

## 람다 표현식

- 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다.

- 특징

  - `익명` : 이름이 없으므로 익명이라 표현
  - `함수` : 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부름. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 방식, 예외 리스트 등을 포함한다.
  - `전달` : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
  - `간결성` : 익명 클래스에 비해 간결함

- 람다 표현식의 구성 요소

  ```java
  (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
  // 파라미터 리스트    화살표        람다 바디
  ```

- 람다 표현식을 통해 구현한 함수형 인터페이스는 해당 인터페이스의 인스턴스로 취급된다.



## 함수 디스크립터

- 함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.

- 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.

- ex)

  | 함수형 인터페이스 | 함수 디스크립터   |
  | ----------------- | ----------------- |
  | Predicate         | T -> boolean      |
  | Consumer          | T -> void         |
  | Function<T,R>     | T -> R            |
  | Supplier          | ( ) -> T          |
  | BiPredicate<L, R> | (L, R) -> boolean |
  | BiConsumer<L, R>  | (T, U) -> void    |
  | BiFunction<T,U,R> | (T, U) -> R       |
  | Runnable          | () -> void        |



## 메소드 참조

- `클래스 내부의 있는 메소드를 직접 호출`해 사용하는 것이다.

- 메소드 참조를 이용해 기존의 메소드 정의를 재활용할 수 있으며 가독성이 이점이 있다. 상황에 맞춰 람다와 병행해서 사용한다면 매우 효과적이다.

- ex)

  ```java
  //람다 표현식
  Arrays.sort(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());)
  
  //메소드 참조
  Arrays.sort(comparing(Apple::getWeight));
  ```

  - 이와 같이 Comparator 인터페이스 안에 있는 comparing 디폴트 메서드를 직접 호출해 사용해줬다.
  - 람다보다 더 간결한 코드가 완성되었다.

- 생성자 참조 : ClassName::new 와 같은 형식으로 생성자를 참조하는 방법도 존재한다.