---
title : 운영체제 - 반효경 4강
category : [CS, OS]
tags : [cs, os]
---



## 프로세스 생성

- 부모 프로세스가 자식 프로세스를 부모를 복제해서 생성 
- 하나의 부모가 여러 자식을 가질 수 있음 -> 프로세스의 트리(계층 구조) 형성
- 자식 프로세스는 리소스들을 부모와 공유하는 경우도 있고, 공유하지 않는 경우도 있음(원칙적으로는 공유 X)
  - 원칙적으로 공유하지 않지만 자식 프로세스가 부모와 똑같은 일을 하다고 했을 때 리소스를 공유하지 않는다면 리소스가 낭비가 됨
  - 그래서 리눅스와 같은 운영체제는 자식과 부모가 똑같을 때는 리소스를 공유하다 다른 일을 시작할 때부터 부모의 주소공간을 copy해서 자식 프로세스의 주소 공간을 만듬
  - 실제 프로그램이 메모리에 올라갈 때 잘게 쪼개 사용하는 부분만 메모리에 올라가는데 이 부분만 copy해서 새로운 주소공간을 만드는 것이다.
  - 이것을 `Copy-On-Writer(COW)`라고 부름
- 수행(Execution) : 부모와 자식이 공존하며 수행하는 모델도 있고, 자식이 종료(terminate)될 때까지 부모가 wait(Blocked)하는 모델도 있음
-  주소 공간 : 자식은 부모의 주소 공간을 복사함(OS data, program counter, PCB 등) -> 복사 후 그 공간에 새로운 프로그램을 덮을 수 있음(운영체제를 통해서 복제)
- `fork()` : 부모 프로세스를 `복제하는 시스템 콜`
- `exec()` : 기존 프로그램에서 새로운 프로그램으로 덮어씌우는 시스템 콜
- fork() -> exec() 순으로 실행된다. 하지만 exec()는 실행할 수도 안 할 수도 있다.

# 프로세스 종료

- 프로세스가 마지막 명령을 수행 후 운영체제에게 이를 알려줌 (exit)

  - 보통 메인 함수의 중괄호 전에 생략되어있음

  - 자식 프로세스는 항상 부모보다 먼저 exit됨

- 부모 프로세스가 자식 프로세스의 수행을 강제 종료시킴 (abort)

  - 자식이 할당 자원의 한계치를 넘을 경우
  - 자식에게 할당된 태스크가 더 이상 필요하지 않는 경우
  - 부모가 exit 되는 경우 -> 항상 자식 프로세스는 부모 프로세스보다 빨리 종료 되어야 하기 때문에 부모가 exit 되는 경우 자식 프로세스도 모두 exit 시킴(단계적으로)



## fork()

![image](https://github.com/user-attachments/assets/9c8d8fc1-e938-4475-80e0-ec7a63f96041)

- fork() 호출 시 리턴값으로 부모와 자식을 구분할 수 있다.
  - return = 0이면 자식, return > 0이면 부모 프로세스를 뜻함
- 주의할 점은 fork()시 program counter도 함께 복사하기 때문에 fork() 위 코드는 실행되지 않고 fork() 다음부터 실행된다

## exec()

- 완전히 새로운 프로그램으로 덮어씌우는 시스템 콜

- 새로운 프로그램은 main()의 처음부터 실행하게 된다

## wait()

- 프로세스 A가 wait()를 호출하면 커널은 child가 종료될 때까지 프로세스 A를 sleep 시킨다(block 상태)
- child가 종료되면 커널은 프로세스 A를 깨운다(ready 상태)
- 프로세스 생성에서 본 수행(Execution) 모델 2개 중 2번째에 해당하는 모델에 사용됨
- 예를 들어 리눅스나 윈도우의 cmd가 있다.

## exit()

- 프로세스의 종료를 알리는 시스템 콜
- 자발적 종료 : 마지막 코드 실행 후 exit() 시스템 콜을 통해 프로그램이 종료됨(main 함수 마지막에 생략)
- 비자발적 종료
  - 부모 프로세스가 자식 프로세스를 강제 종료 : 자식이 한계치를 넘어서는 자원 요청시, 자식에게 할당된 태스크 필요 X 할 때 등
  - 키보드로 kill, break 등을 친 경우(ctrl + c)
  - 부모가 종료되는 경우



## 프로세스 간 협력

- 독립적 프로세스(Independent process) : 프로세스는 각자의 주소 공간을 가지고 수행됨. 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함

- 협력 프로세스(Cooperating process) : 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

- `프로세스 간 협력 메커니즘(IPC : Interprocess Commnuication)`

  - `message passing` : 

    - `메시지를 전달하는 방법`
    - 커널을 통해 메시지 전달

    - Direct Communication : 통신하려는 프로세스의 이름을 명시적으로 표시
    - Indirect Communication : mailbox (또는 port)를 통해 메시지를 간접 전달, 여러 프로세스에게 전달 가능

    ![image](https://github.com/user-attachments/assets/6005abdb-cc73-412e-922a-1df7fc015024)

  - `shared memory` 

    - `주소 공간을 공유하는 방법`
    - 서로 다른 프로세스 간에도 일부 주소 공간을 공유하는 shared memory 메커니즘이 있음
    -  커널에게 메모리를 공유한다는 사실을 알리는 시스템 콜을 해줘야 함
    - 주소 공간을 공유하기 때문에 서로 신뢰할 수 있는 프로세스여야 함

  ![image](https://github.com/user-attachments/assets/ed4b4161-9f83-467d-8af0-ee548e59ecda)

- Thread : thread도 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵다. 하지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능



출처)

[운영체제 - 이화여자대학교 | KOCW 공개 강의](http://www.kocw.net/home/cview.do?cid=3646706b4347ef09)