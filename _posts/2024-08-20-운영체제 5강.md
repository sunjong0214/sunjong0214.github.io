---
title : 운영체제 - 반효경 5강
category : [CS, OS]
tags : [cs, os]
---



## 프로그램 실행 시 흐름

![image](https://github.com/user-attachments/assets/84f5ff5f-2b8d-4043-a673-e25cb95915d9)

- 그림과 같이 CPU를 사용하는 CPU burst와 I/O를 하는 I/O burst를 반복적으로 실행하게 된다

## CPU-burst Time의 분포

![image](https://github.com/user-attachments/assets/1a49797f-7f3a-40ae-ac77-85dd8f474d97)

- 위 그림으로 알 수 있는 사실은 I/O bound job = CPU를 짧게 자주 I/O로 바뀜, CPU bound job = 실제로 CPU를 길게 씀
- CPU 스케줄링이 필요한 이유
  - 만약 CPU bound job과 I/O bound job에게 공평하게 CPU를 할당하면 사람과 직접 연관있는  interactive job인 I/O job이 오래 기다려야 함 -> 사람이 답답함
  - 이런 이유 때문에 CPU bound job과 I/O bound job의 우선순위를 적절히 정해줘야 함 -> 스케줄링이 필요함 



## 프로세스의 특성 분류

- `I/O-bound process` : CPU를 잡고 계산한느 시간보다 I/O에 많은 시간이 필요한 job, many short CPU bursts
- `CPU-bound process` : 계산 위주의 job, few very long CPU bursts



## CPU Scheduler & Dispatcher

- `CPU Scheduler` : Ready 상태의 프로세스 중 어떤 프로세스에게 CPU를 줄지 선택해주는 코드
- `Dispatcher` : CPU의 제어권을 CPU scheduler에 의해 선택된 프로세스에게 CPU를 넘겨주는 코드, context switch라고 함

- `nonpreemptive(자진 반납)` : Runing -> Blocked, Terminate의 경우 
- `preemptive(강제로 뺐음)` : Runing -> Ready, Blocked -> Ready



출처)

[운영체제 - 이화여자대학교 | KOCW 공개 강의](http://www.kocw.net/home/cview.do?cid=3646706b4347ef09)