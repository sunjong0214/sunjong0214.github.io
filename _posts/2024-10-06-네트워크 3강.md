---
title : network 3강 - Transport layer
category : [CS, network]
tags : [cs, network]
---



## Multiplexing/Demultiplexing

- multiplexing : 애플리케이션 계층에서 내려온 message들을 세그먼트로 만들어주는 것
- demultiplexing : 네트워크 게층에서 올라온 segment를 올바른 프로세스의 소켓으로 보내주는 것

![image](https://github.com/user-attachments/assets/e24b302a-bae9-4379-b79c-b3c749fe67cb)

- demultiplexing 할 때 어느 프로세스로 보낼 지 정하는 것은 들어온 segment의 헤더 중 source port와 dest port로 결정한다.

![image](https://github.com/user-attachments/assets/5c763f67-6526-47a6-8132-9b5511af98d0)

#### UDP의 Demultiplexing

- UDP는 오직 dest ip와 dest port를 이용해 demultiplexing이 이루어진다.

#### TCP의 multiplexing

- TCP는 dest ip, dest port 뿐만 아니라 src ip, src port를 이용해 demultiplexing 한다. 즉, 위 4 중 하나라도 다르면 다른 소켓으로 보낸다.

- 위의 두 protocol을 살펴보면 TCP의 경우 1대1로 소켓이 연결되고, UDP는 어디서 오든 상관없이 dest ip와 dest port만을 보고 해당 소켓으로 보내기 때문에 다른 특정 프로세스와 연결되어 있지 않다(1대1이 아님). 이렇듯 TCP는 연결형, UDP는 비연결형이란 사실을 알 수 있다.



## UDP

![image](https://github.com/user-attachments/assets/040d91b6-1825-4993-9289-c0d40144cc7a)

- UDP는 최소한의 서비스만 제공
- multiplexing/demultiplexing과 에러 발생 여부를 판단하는 checksum만이 존재한다.



## TCP

- TCP가 제공하는 여러 서비스는 환상 같은 일 -> TCP 아래의 계층들은 사실 신뢰성을 보장하지 못해줌(라우터 큐가 가득차 패킷 로스 등)
- 하지만 2가지 문제(패킷 에러, 패킷 로스)만 해결하면 reliable한 전송이 가능하다.

### TCP의 Reliable data transfer를 위한 매커니즘

#### 패킷 에러 해결방안

- checksum bits를 통해 에러 detection

- 잘 받았다와 같은 feedback 필요

  - ACKs / NAKs

- 재전송

  ![image](https://github.com/user-attachments/assets/b1f6c621-de7e-417f-8461-65d44960b862)

- 문제 : 만약 feedback에 에러가 발생하면?

  - 에러가 발생하면 그냥 재전송
  - 하지만 재전송했을 때도 문제가 있다
  - receiver 입장에서 재전송된 패킷 에러 때문에 재전송한거지 중복된 메시지인지 알 수 없음 (ex) potato potato의 경우 두번째로 온 potato가 에러인지, 제대로 된 메시지인지 모름)
  - 이런 문제를 해결하기 위해 메시지에 번호를 붙임 -> sequence number

- NAK없이 ACK만을 사용 -> ACK에 받은 seq number를 포함해서 확인

#### 패킷 로스 해결방안

- Timer를 사용
- feedback이 일정시간 오지 않으면 재전송
- Timer의 시간 설정은 중요한 문제
  - Timer가 짧으면 로스가 발생 시 빨리 재전송, 하지만 정상적으로 가고 있지만 돌아가느라 오래 걸린 경우 로스가 아님에도 재전송(네트워크 오버헤드  발생)
  - Timer가 긴 경우 로스가 발생했을 때 receiver가 오래 기다림, 하지만 정상 흐름의 경우 오버헤드 적게 발생



