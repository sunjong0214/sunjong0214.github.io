---
title : network 3강 - Transport layer
category : [CS, network]
tags : [cs, network]
---



## Multiplexing/Demultiplexing

- multiplexing : 애플리케이션 계층에서 내려온 message들을 세그먼트로 만들어주는 것
- demultiplexing : 네트워크 게층에서 올라온 segment를 올바른 프로세스의 소켓으로 보내주는 것

![image](https://github.com/user-attachments/assets/e24b302a-bae9-4379-b79c-b3c749fe67cb)

- demultiplexing 할 때 어느 프로세스로 보낼 지 정하는 것은 들어온 segment의 헤더 중 source port와 dest port로 결정한다.

![image](https://github.com/user-attachments/assets/5c763f67-6526-47a6-8132-9b5511af98d0)

#### UDP의 Demultiplexing

- UDP는 오직 dest ip와 dest port를 이용해 demultiplexing이 이루어진다.

#### TCP의 multiplexing

- TCP는 dest ip, dest port 뿐만 아니라 src ip, src port를 이용해 demultiplexing 한다. 즉, 위 4 중 하나라도 다르면 다른 소켓으로 보낸다.

- 위의 두 protocol을 살펴보면 TCP의 경우 1대1로 소켓이 연결되고, UDP는 어디서 오든 상관없이 dest ip와 dest port만을 보고 해당 소켓으로 보내기 때문에 다른 특정 프로세스와 연결되어 있지 않다(1대1이 아님). 이렇듯 TCP는 연결형, UDP는 비연결형이란 사실을 알 수 있다.



## UDP

![image](https://github.com/user-attachments/assets/040d91b6-1825-4993-9289-c0d40144cc7a)

- UDP는 최소한의 서비스만 제공
- multiplexing/demultiplexing과 에러 발생 여부를 판단하는 checksum만이 존재한다.



## TCP

- TCP가 제공하는 여러 서비스는 환상 같은 일 -> TCP 아래의 계층들은 사실 신뢰성을 보장하지 못해줌(라우터 큐가 가득차 패킷 로스 등)
- 하지만 2가지 문제(패킷 에러, 패킷 로스)만 해결하면 reliable한 전송이 가능하다.

### TCP의 Reliable data transfer를 위한 매커니즘

#### 패킷 에러 해결방안

- checksum bits를 통해 에러 detection

- 잘 받았다와 같은 feedback 필요

  - ACKs / NAKs

- 재전송

  ![image](https://github.com/user-attachments/assets/b1f6c621-de7e-417f-8461-65d44960b862)

- 문제 : 만약 feedback에 에러가 발생하면?

  - 에러가 발생하면 그냥 재전송
  - 하지만 재전송했을 때도 문제가 있다
  - receiver 입장에서 재전송된 패킷 에러 때문에 재전송한거지 중복된 메시지인지 알 수 없음 (ex) potato potato의 경우 두번째로 온 potato가 에러인지, 제대로 된 메시지인지 모름)
  - 이런 문제를 해결하기 위해 메시지에 번호를 붙임 -> sequence number

- NAK없이 ACK만을 사용 -> ACK에 받은 seq number를 포함해서 확인

#### 패킷 로스 해결방안

- Timer를 사용
- feedback이 일정시간 오지 않으면 재전송
- Timer의 시간 설정은 중요한 문제
  - Timer가 짧으면 로스가 발생 시 빨리 재전송, 하지만 정상적으로 가고 있지만 돌아가느라 오래 걸린 경우 로스가 아님에도 재전송(네트워크 오버헤드  발생)
  - Timer가 긴 경우 로스가 발생했을 때 receiver가 오래 기다림, 하지만 정상 흐름의 경우 오버헤드 적게 발생



## 네트워크 이용률

- 만약 TCP 통신을 하면서 하나의 패킷만을 주고 받으면 어떻게 될까?
- sender가 패킷을 보낸 후 receiver가 ACK가 올 때까지 sender는 쉬게 된다 -> 네트워크 이용률 낮음
- 이용률을 높이기 위해서는 패킷을 여러개 보낼 수 있어야 한다(reliable을 지키면서).

![image](https://github.com/user-attachments/assets/c831540f-7497-4e34-9443-7dd28dae2b41)

- 패킷을 보내고 피드백이 오기 전에 또 다른 패킷을 보내는 것을 파이프라인 방식이라고 한다.
- 이 파이프라인은 2가지 방식으로 구현된다 -> go-Back-N, selective repeat

#### go-Back-N

- 패킷을 얼마나 보낼지를 정한 window size만큼 피드백을 받기 전에 패킷을 보내는 방식이다.

![image](https://github.com/user-attachments/assets/50f35cfc-f7b6-47b1-ad96-6402e0bfb75f)

- go-back-n은 ACK에 sequence 번호를 붙여서 보내는데 이 번호의 의미는 해당 번호까지 잘 받았다는 의미 -> ACK 11이라면 12번 받을 차례

- 만약 위도우 사이즈가 5일 때, 각 패킷에는 타이머가 각각 존재하는데 1번 패킷이 타이머가 터지면 1~4번을 모두 재전송한다.(윈도우에 있는 터이머 터진 패킷보다 더 큰 번호를 가진 패킷 다 재전송)

- receiver의 입장에서는 단순하다.

  - PKT 0 받음 -> ACK 0을 보내고 1번을 기다림
  - PKT 1번보다 2번이 더 빨리옴 -> 1번을 받아야하기 때문에 2번은 버림 다시 ACK 0
  - PKT 1번이 뒤늦게 도착 -> 잘 받음 ACK 1
  - PKT 3이 옴 -> 2번 패킷을 받아야하기 때문에 3번은 버림
  - PKT 2번이 ACK 2를 받지 못해서 Timeout 터짐 -> sender는 PKT 2번부터 다시 다 재전송
  - 이때 window는 0번과 1번은 잘 받았기 때문에 한 칸 씩 전진함 -> 위의 상황에서 timeout시 재전송하는 PKT[2, 3, 4, 5] (window size = 4)

  ![image](https://github.com/user-attachments/assets/87156ef4-34c9-48a9-acfe-226e2e7db317)

- window안에 있는 pkt들은 결국 receiver가 받았는지 확인이 필요한 pkt이므로 저장 -> window = buffer와 같은 의미
- go-back-n의 경우 하나의 패킷만 유실되도 n만큼 재전송해야한다. 실제 window 사이즈는 매우 크므로 그 사이즈 만큼 재전송하는 것은 매우 비효율 -> 이걸 보안한게 Selective repeat

#### Selective Repeat

- go-back-n과 다르게 재전송 해야하는 패킷만 재전송하는 방식
- selective repeat의 ACK는 go-back-n과 다르게 사용
  - go-back-n : ACK의 번호는 해당 번호까지 잘 받았다는 의미
  - selective repeat : ACK의 번호는 해당 번호의 패킷을 잘 받았다는 의미 -> ACK 온 번호의 패킷은 타이머 해제
- go-back-N과 다르게 receiver의 역할이 더 생김
  - 순서에 맞지 않게 온 패킷들도 받아들이고 buffer에 저장 후 ACK를 보냄

![image](https://github.com/user-attachments/assets/99c2a594-a077-4b52-94e3-bcc73c76ca02)



- 이런 sequence 번호를 사용할 때 주의할 점은 sequence 번호를 무한정 늘리면 그만큼 오버헤드가 발생한다는 것이다. 그래서 sequence 번호를 적절히 설정하는 것이 중요한데 보통 window size * 2 정도로 생각하자
- 실제 TCP에서는 이 두 방식의 장점을 합쳐서 사용한다. selective repeat과 같은 방식은 좋아보이지만 모든 패킷에 타이머를 달아야한다는 단점이 있다. 실제 window 크기는 매우 크기 때문에 모든 패킷에 타이머를 다는 것은 현실적으로 불가능하다. 
