---
title : network 5강 - Link layer
category : [CS, network]
tags : [cs, network]
---



## Link layer

- 지금까지 패킷을 라우터를 통해 어떻게 dest로 보내는지에 대해 설명했다.
- 실제로 우리가 패킷을 만들어서 통신하기 위해서는 처음 네트워크 밖으로 보내는 라우터인 게이트웨이 라우터에게 패킷을 보내거나 라우터에서 라우터로 패킷을 보낼 때 어떤 방식으로 보낼까?
- 네트워크 안에서는 라우터와 라우터 간 1대1로 매칭되어 연결되어있는 것이 아니라 하나의 라우터에 여러 라우터가 연결되어있다.
- 그럴 상황에서 라우터가 라우터에게 패킷을 보내고자 할 때 결국 이 패킷이란 것은 파장이므로 연결되어있는 모든 곳에 퍼지게 된다. (우리가 말할 때 공기에 퍼지듯)
- 근데 여기서 한 라우터에 패킷을 보내는 도중에 또 다른 라우터가 패킷을 보내면 어떻게 될까? 패킷은 파장이라 모든 곳에 퍼진다고 했다.
- 첫번째 보낸 패킷과 다른 라우터에서 보낸 두번째 패킷이 서로 섞이면서 알아볼 수 없게 된다. 이런 현상을 collision이라고 하며 이 링크 레이어에서 가장 중요하게 하는 일은 collision을 발생하지 않게 하고, 발생했다면 해결하는 일을 한다.

## Medium Access Control(MAC)

- 여러명이 한 매체를 공유하는 상황(multiple access)에서 패킷을 전송할 때 충돌이 안 나게 컨트롤하는 것을 MAC이라고 한다. 

#### Time Division multiple access(TDMA)

- MAC protocol 중 하나로 시간을 쪼개서 multiple access 상황을 해결

  ![image](https://github.com/user-attachments/assets/ab05de87-d47c-4558-baec-c2ab47e95443)

- slot의 수보다 사용자가 적으면 리소스가 낭비

- 이와 비슷한 MAC protocol로 FDMA가 있는데 TDMA와의 차이는 시간 대신 전자파를 이용한 방식으로 비슷한 장단점을 가진다.

#### Random access protocol

![image](https://github.com/user-attachments/assets/9bb99ca7-af46-4179-bc87-88f9b962920c)

- TDMA와 다르게 보내고 싶을 때 보내는 방식
- Random access protocols는 충돌이 발생하는데 이 충돌을 어떻게 감지하고 해결하는 것이 핵심이다.

#### CSMA

- Random access protocol로 패킷을 전송하기 전에 누군가 전송하고 있는지 확인하고, 없다면 전송을 시작하는 프로토콜이다.
- 하지만 CSMA도 충돌이 발생하는 경우가 있다.

![image](https://github.com/user-attachments/assets/fd8120e7-2db2-4ff6-8644-7096353ed760)

- 위 그림과 같은 상황에서 collision이 발생한다. propagation delay때문에 발생하는데 이 delay는 해결할 수 없는 문제이기 때문에  CSMA를 사용하면 충돌은 피할 수 없다고 결론이 났다.

- 이런 문제를 완화하기 위해 충돌이 감지되는 순간 전송을 멈추는 방식이 CSMA를 업그레이드한 CSMA/CD이다. (CSMA는 멈추지 않고 끝까지 전송)

- 하지만 이 CSMA/CD도 애매한 부분이 있다. 바로 충돌을 감지해서 전송을 멈춘 뒤 누가 먼저 전송을 시작할 것 인가이다.

- 이를 이해 도입한 방법이 `binary backoff` 이다.

  ![image](https://github.com/user-attachments/assets/8e2e8c1d-6285-4bb4-b500-fdd2502facd7)

  - 충돌이 m번 발생했을 때 2^m-1 만큼의 수열 중 랜덤한 숫자를 고르고 그 수만큼 기다린 후 전송하는 방식이다.
  - 첫번째 충돌 : {0, 1} 중 선택, 2번째 충돌 : {0, 1, 2, 3} 중 선택

- 주변에 같은 와이파이를 쓰는 사람이 많으면 인터넷 속도가 느려지는 이유가 바로 binary backoff 때문이다. (사람이 많으면 많을 수록 길어짐)

- 우리가 평소에 사용하는 Ethernet은 이 CSMA/CD를 사용한다.

## Local Area Network(LAN)

- 같은 서브넷을 가진 라우터를 거치지 않고 접근이 가능한 host들의 집합

#### Ethernet

- 유선을 사용해 LAN을 구현한 방식

![image](https://github.com/user-attachments/assets/6dc72829-c100-40b1-92ca-199a977fb678)

- 최근에는 보통 star 형식으로 사용
- Ethernet은 CSMA/CD MAC protocol을 사용

- 근데 이더넷에서 collision이 발생했을 때 100% collision을 detect할 수 있을까? 답은 아니다.
  - A가 전송 시작
  - A가 전송한 프레임이 E에게 닿기 직전에 E가 listen -> 전송 중이 없어서 E가 전송 시장
  - A가 보낸 frame과 collision 발생 -> E 전송 멈춤
  - E가 보낸 frame이 A가 frame 전송 중에 A에게 도착해야 collision detect 완료
  - 하지만 E가 보낸 frame이 들어오기 전에 A가 전송을 끝냄
  - detect 실패
- 위와 같은 시나리에서 detect를 실패하게 된다.
- 이 때문에 이더넷에서는 frame의 최소 크기를 정해놓았다. 그 크기는 64byte이다. 64byte 이상 보내야 위와 같은 상황이 발생하지 않는다.



## MAC address

![image](https://github.com/user-attachments/assets/30ad1080-e0e1-4ed7-9a0b-657155a82bd4)

- 링크 레이어의 헤더에는 dest, source address를 가지고 있는데, 이 address는 MAC address를 뜻 한다.
- MAC address는 네트워크 인터페이스를 식별할 수 있는 주소로,  48 bit를 가진 주소이다.
- MAC address는 제조사를 식별하는 24 bit와 나머지 24 bit는 제품 번호를 뜻 한다. 이 MAC address는 주민번호와 같이 바꿀 수 없는 번호이다.

![image](https://github.com/user-attachments/assets/d391508d-02cc-446c-b97b-242a9dc97979)

#### ARP

- 결국 처음 사용자가 다른 네트워크로 요청을 보내고 싶다면 게이트웨이 라우터로 보내야한다.
- 그렇다면 DHCP를 통해 게이트웨이 라우터의 IP는 알고 있지만 frame을 만들라면 dest address에 게이트웨이 라우터의 MAC address를 넣어야하는데 이걸 어떻게 알 수 있을까?
- 그 방법은 다음과 같다.
- 각 컴퓨터 내부에는 ARP(address resolution protocol) table이 존재한다. 이 ARP table를 확인하면 Ip address로 MAC address를 찾을 수 있다.
- 하지만 ARP  table에 게이트웨이 라우터의 정보가 없다면 어떻게 할까?
- 그럴 때는 ARP request를 통해 게이트웨이 라우터의 MAC address를 찾아온다.
- ARP request는 브로드캐스트로 요청을 보내고 data 부분에 MAC address를 찾고 있는 장치의 IP address를 담아서 보낸다. 그 후 IP address에 해당하는 장치는 응답을 보낸다.
- 이런 방식으로 MAC address를 찾게 된다.





출처)

[컴퓨터네트워크 - 한양대학교 | KOCW 공개 강의](http://www.kocw.net/home/search/kemView.do?kemId=1169634)