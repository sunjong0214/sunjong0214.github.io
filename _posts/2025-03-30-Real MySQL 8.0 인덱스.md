---
title : Real MySQL 8.0 - 인덱스
category : [DB]
tags : [db, index]
---

- # 인덱스

  ## 1. 랜덤 IO와 순차 IO

  - 랜덤 IO는 3개의 페이지를 가져오기 위해 3번의 시스템 콜 필요 (랜덤으로 위치한 페이지를 가져오기 때문에 당연)
  - 순차 IO는 한번의 시스템 콜로 처리 가능
  - 그만큼 랜덤 IO는 속도가 매우 떨어짐
  - 쿼리 튜닝은 이런 랜덤 IO를 순차 IO로 바꾸기 위함이라고 생각하면 됨
  - 특히, 쿼리 시 index range scan은 랜덤 IO로 실행됨
    - 많은 레코드를 읽어야할 때 성능이 떨어지므로 오히려 full scan으로 처리할 때도 있음 (full scan은 순차 IO 사용)

  ## 2. 인덱스란

  - 인덱스는 책의 맨 끝에 있는 찾아보기와 같음
  - DBMS에서도 빠르게 원하는 결과를 찾기 위해 칼럼들의 값과 해당 레코드의 주소를 key-value로 저장한 것이 인덱스
  - 인덱스는 찾아보기와 같이 정렬이 가장 중요함
    - ㄱ, ㄴ, ㄷ, ㄹ와 같이 정렬되어있으면 더 빠르게 찾을 수 있는 것처럼 인덱스도 해당 칼럼의 값으로 정렬되어있음
  - DBMS의 인덱스는 SortedList / 실제 저장 데이터는 ArrayList
    - 각 자료구조의 장단점이 곧 인덱스의 장단점이 됨
    - 항상 정렬되어있는 SortedList는 insert, update, delete는 느리지만, 정렬되어있어 select는 매우 빠름
  - 인덱스 설정 시 읽기 성능과 쓰기 성능의 균형을 잡는 것이 중요
    - 무조건 where문에 들어있다고 인덱스 설정하지 않음
  - 인덱스는 PK와 그 외 세컨더리 인덱스로 나뉨
  - 인덱스 알고리즘은 보통 B-Tree 인덱스와 Hash 인덱스로 나뉨
    - B-Tree 인덱스: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱
    - Hash 인덱스: Hash 값을 계산해서 인덱싱
      - 칼럼의 값을 변형해 Hash 값을 바꾸기 때문에 값의 일부만 검색하거나 범위를 검색할 때는 사용하지 못함
      - 보통 메모리 기반 DB에서 사용
  - 유니크 인덱스와 그렇지 않은 인덱스의 차이
    - DB 입장에서 유니크 인덱스인 경우 중복이 존재하지 않는다는 의미
    - 옵티마이저 입장에서는 매우 중요한 문제
      - equal 조건으로 검색 시 유니크 인덱스는 1개만 찾으면 나머지는 찾지 않아도 됨을 옵티마이저에게 알려주는 효과
      - 유니크 인덱스는 처리 방식이 기존의 것과 많은 차이점이 있음

  ## 3. B-Tree

  - B-Tree(balanced tree)는 인덱싱 알고리즘 중 가장 오래된 알고리즘
    - 변형된 알고리즘: B+-Tree, B*-Tree 등
  - 대부분의 인덱스는 B-Tree 인덱스를 사용하며 원래 값을 변형시키지 않고 사용
  - B-Tree의 구조
    - 최상위의 루트 노드
    - 최하위의 리프 노드
    - 중간에 존재하는 브랜치 노드
  - B-Tree의 리프 노드에는 데이터 파일에 해당 레코드의 주소 값이 저장 (InnoDB의 경우 프라이머리 키의 주소값)
  - 인덱스는 항상 정렬되어있지만 실제 데이터 파일은 그렇지 않음
    - insert만 일어난다면 정렬되어있겠지만 delete로 빈 공간이 생기면 이 공간을 재활용
    - InnoDB의 경우 클러스터되어 디스크에 저장되므로 기본적으로 PK 순으로 정렬
    - InnoDB는 클러스터링 테이블을 기본적으로 만들고 비슷한 값을 최대한 모아서 저장
  - InnoDB에서 실제 인덱스를 통해 데이터를 찾는 과정
    - 인덱스를 통해 리프 노드에 저장된 PK 주소로 찾아감
    - PK의 리프 노드를 찾아가 실제 레코드를 탐색
    - 결국 B-Tree를 두 번 타게 됨

  ### B-Tree 인덱스 키의 추가/삭제/변경

  - 추가 :
    - 추가된 키 값이 B-Tree의 어느 위치에 저장되어야 하는지 찾음 (정렬 필요)
    - 위치를 찾은 후 해당 위치에 저장
    - 리프 노드가 꽉차서 저장할 수 없을 경우 리프 노드를 분리 (상위 브랜치 노드까지 처리 범위가 늘어남)
    - 이런 이유로 B-Tree 인덱스는 쓰기 작업에 비용이 많이 발생
  - 삭제 :
    - 저장된 B-Tree 리프 노드를 찾아 삭제 마크를 남김
    - 해당 공간을 재사용하거나 방치하는 방식으로 동작
  - 변경 :
    - 단순히 키 값만 변경하는 것이 아님
    - B-Tree의 키 값을 삭제한 뒤 변경된 값을 새로 추가하는 방식으로 동작
  - InnoDB 엔진은 체인지 버퍼를 활용해 위의 작업들을 지연처리할 수 있음

  ### 인덱스 키 검색

  - B-Tree 인덱스를 이용한다면 매우 빠른 검색 속도 보장
  - 키 검색은 select 뿐만 아니라 update, delete와 같이 레코드를 먼저 검색해야할 때도 사용
  - B-Tree 인덱스 검색은 100% 일치 혹은 앞부분만 일치하는 경우에 사용 가능
    - 키의 뒷 부분만 검색하는 경우에는 인덱스의 빠른 검색을 이용하기 어려움 (정렬 특성 때문)
  - InnoDB 엔진에서 인덱스의 특별한 의미
    - InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락은 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 동작
    - update나 delete 시 적절한 인덱스가 없다면 불필요하게 많은 레코드를 잠금
    - 적절한 인덱스 설계가 중요한 이유

  ### 선택도(Selectivity) / 기수성(Cardinality)

  - 키 값 가운데 유니크한 값의 수를 의미
  - 인덱스에 중복된 값이 많을수록 선택도/기수성이 떨어짐
  - 인덱스는 선택도가 높을수록 검색 대상이 줄어들어 처리가 빠름
  - 같은 쿼리라도 선택도가 높을수록 해당 값을 가져오기 위해 읽는 레코드 건수가 유의미하게 차이남
  - 인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미침

  ### 인덱스 읽기 비용

  - 인덱스를 통해 레코드를 읽는 것은 바로 테이블의 레코드를 읽는 것보다 높은 비용이 발생 (B-Tree를 거쳐야 하므로)
  - 예시: 테이블 레코드가 100만건 있을 때 50만건을 읽는 쿼리
    - 인덱스를 통해 50만건을 가져오는 비용 vs 100만건을 전부 읽고 50만건을 버리는 비용
  - 일반적인 DBMS 옵티마이저는 인덱스를 거쳐 데이터를 읽는 방식이 약 4~5배 더 비용이 든다고 예측
  - 보통 전체의 20~25% 이상 데이터를 읽어야한다면 풀 스캔 방식 적용

  ### 인덱스 스캔 방식

  #### 1. 인덱스 레인지 스캔

  - 검색해야 할 인덱스 범위가 결정되었을 때 사용
  - B-Tree 중 시작점에 해당하는 리프 노드를 찾아 순차적으로 읽는 방식
  - 읽어들이는 레코드 한 건마다 랜덤 IO를 통해 실제 데이터 블록에서 읽음
  - 과정:
    1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾음 (index seek)
    2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽음 (index scan)
    3. 2번에서 읽은 인덱스 키와 레코드 주소를 이용해 데이터를 가져옴
  - 커버링 인덱스를 이용하면 3번 과정을 생략할 수 있어 비용 절감

  #### 2. 인덱스 풀 스캔

  - 레인지 스캔과 마찬가지로 인덱스를 사용하되 처음부터 끝까지 모두 읽는 방식
  - 주로 사용되는 경우:
    - 쿼리의 where절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 (복합 인덱스 (a, b, c)일 때 b, c만 쓰이는 경우)
    - 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우
  - 인덱스뿐만 아니라 데이터 블록에 접근해야한다면 사용되지 않음
  - 인덱스를 효율적으로 활용하지 못하는 방식

  #### 3. 루스 인덱스 스캔

  - '타이트 인덱스 스캔'과 달리 느슨하게 인덱스를 읽는 방식
  - 중간에 필요하지 않은 인덱스 키를 무시하고 넘어가는 형태로 처리
  - 일반적으로 GROUP BY나 MIN, MAX 함수에 사용
  - 예: 복합 인덱스가 (a, b)가 있을 때 WHERE 절에 a만 있을 시 b는 확인하지 않고 쿼리 수행

  #### 4. 인덱스 스킵 스캔

  - MySQL 8.0 버전부터 도입
  - 복합 인덱스의 첫 번째 칼럼이 WHERE 절에 없어도 뒤의 칼럼으로 인덱스 검색 가능
  - 작동 방식:
    - 예: 복합 인덱스 (a, b)가 있고 쿼리 조건에 b만 있을 경우
    - 옵티마이저가 a의 유니크한 값들을 모두 조회
    - 조회된 값들을 이용해 쿼리를 여러 개로 분리해 실행
      - 기존: `SELECT ~ FROM ~ WHERE b = 값`
      - 스킵 스캔: `SELECT ~ FROM ~ WHERE a = 'c' AND b = 값; SELECT ~ FROM ~ WHERE a = 'd' AND b = 값;`
  - 제약 사항:
    - a의 유니크한 값이 적어야 효율적
    - 커버링 인덱스여야만 처리 가능